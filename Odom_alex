#include <ros/ros.h>
#include <std_msgs/Int32.h>
#include <geometry_msgs/Quaternion.h>
#include <tf/transform_broadcaster.h>
#include <nav_msgs/Odometry.h>
#include <cmath>
#include <boost/assign/list_of.hpp>

#define PI 3.14159265
#define TwoPI 6.28318531
#define wheeltrack 0.340   // units: m  
#define EncoderCountsPerWheel 396
#define wheelradius 0.0425  // units: m

long _PreviousLeftEncoderCounts = 0;
long _PreviousRightEncoderCounts = 0;
ros::Time current_time, last_time;
double DistancePerCount = (3.14159265 * 2 * wheelradius) / (EncoderCountsPerWheel * 4); // the wheel diameter is 0.085m

// Final odometric data
double x = 0.0;
double y = 0.0;
double th = 0.0;
double v_left = 0.0;  // left motor speed
double v_right = 0.0; // right motor speed
double vth = 0.0;     // angular velocity of robot
double deltaLeft = 0.0; // no of ticks in left encoder since the last update
double deltaRight = 0.0; // no of ticks in the right encoder since the last update
double dt = 0.0;
double delta_distance = 0.0; // distance moved by robot since the last update
double delta_th = 0.0; // corresponding change in heading
double delta_x = 0.0; // corresponding change in x direction
double delta_y = 0.0; // corresponding change in y direction

void LeftWheelCallback(const std_msgs::Int32::ConstPtr& l_enc)
{
  current_time = ros::Time::now();

  deltaLeft = l_enc->data - _PreviousLeftEncoderCounts;

  dt = (current_time - last_time).toSec();

  v_left = deltaLeft * DistancePerCount / dt;    // speed = m/s

  delta_distance = deltaLeft * DistancePerCount;
  delta_th = delta_distance / wheeltrack;

  delta_x = delta_distance * cos(th);
  delta_y = delta_distance * sin(th);

  x += delta_x;
  y += delta_y;
  th += delta_th;

  _PreviousLeftEncoderCounts = l_enc->data;

  last_time = current_time;
}

void RightWheelCallback(const std_msgs::Int32::ConstPtr& r_enc)
{
  current_time = ros::Time::now();

  deltaRight = r_enc->data - _PreviousRightEncoderCounts;

  dt = (current_time - last_time).toSec();

  v_right = deltaRight * DistancePerCount / dt;

  delta_distance = deltaRight * DistancePerCount;
  delta_th = -delta_distance / wheeltrack;

  delta_x = delta_distance * cos(th);
  delta_y = delta_distance * sin(th);

  x += delta_x;
  y += delta_y;
  th += delta_th;

  _PreviousRightEncoderCounts = r_enc->data;

  last_time = current_time;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "odometry_publisher");
  ros::NodeHandle nh;

  ros::Subscriber left_encoder_sub = nh.subscribe("/motor_left/encoder", 10, LeftWheelCallback);
  ros::Subscriber right_encoder_sub = nh.subscribe("/motor_right/encoder", 10, RightWheelCallback);
  ros::Publisher odom_pub = nh.advertise<nav_msgs::Odometry>("odom", 50);
  tf::TransformBroadcaster odom_broadcaster;

  ros::Rate r(100);

  while(nh.ok())
  {
    //since all odometry is 6DO F we'll need a quaternion created from yaw
            geometry_msgs::Quaternion odom_quat = tf::createQuaternionMsgFromYaw(th);

 //first, we'll publish the transform over tf
    geometry_msgs::TransformStamped odom_trans;
    odom_trans.header.stamp = current_time;
    odom_trans.header.frame_id = "odom";
    odom_trans.child_frame_id = "base_link";

    odom_trans.transform.translation.x = x;
    odom_trans.transform.translation.y = y;
    odom_trans.transform.translation.z = 0.0;
    odom_trans.transform.rotation = odom_quat;

    //send the transform
    odom_broadcaster.sendTransform(odom_trans);

    //next, we'll publish the odometry message over ROS
    nav_msgs::Odometry odom;
    odom.header.stamp = current_time;
    odom.header.frame_id = "odom";
    //set the position
    odom.pose.pose.position.x = x;
    odom.pose.pose.position.y = y;
    odom.pose.pose.position.z = 0.0;
    odom.pose.pose.orientation = odom_quat;
    odom.pose.covariance =  boost::assign::list_of(1e-3) (0)   (0)  (0)  (0)  (0)
                                                   (0) (1e-3)  (0)  (0)  (0)  (0)
                                                   (0)   (0)  (1e6) (0)  (0)  (0)
                                                   (0)   (0)   (0) (1e6) (0)  (0)
                                                   (0)   (0)   (0)  (0) (1e6) (0)
                                                   (0)   (0)   (0)  (0)  (0)  (1e3) ;
    //set the velocity
    odom.child_frame_id = "base_link";

odom.twist.twist.linear.x=delta_x/dt;
    odom.twist.twist.linear.y=delta_y/dt;
    odom.twist.twist.angular.z = delta_th/dt;
    odom.twist.covariance =  boost::assign::list_of(1e-3) (0)   (0)  (0)  (0)  (0)
                                                    (0) (1e-3)  (0)  (0)  (0)  (0)
                                                    (0)   (0)  (1e6) (0)  (0)  (0)
                                                    (0)   (0)   (0) (1e6) (0)  (0)
                                                    (0)   (0)   (0)  (0) (1e6) (0)
                                                    (0)   (0)   (0)  (0)  (0)  (1e3) ; 

    // ROS_INFO("Position x = %d and Position y = %d ",x,y);

    //publish the message
    odom_pub.publish(odom);

    last_time = current_time;
    ros::spinOnce();
    r.sleep();
    }
}

